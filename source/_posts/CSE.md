---
title: 《计算机系统工程》课程笔记
date: 2024-09-19 14:06:41
categories: 课程笔记
tags:
  - 分布式
index_img:
banner_img:
excerpt: " "
---

## LEC 2: The Case for A Distributed System

- 现代互联网应用具有的特征：
  1. 高请求率 每日数以百万计的请求
  2. 大量的数据 包括图片视频
  3. 对用户透明：用户不会知道服务器的状态 即无感知
  4. AI 带来的新需求：需要高算力（GPU）

### Case Study：以淘宝电商平台为例

- 旧时代的单主机部署：LAMP（Linux+Apache+MySQL+PHP）这种架构无法扩展 单主机的资源始终是有限的

- 如何扩展架构性能？

  1. 分解应用：做出专门定制的硬件 比如专门用于存储数据的服务器 将架构分解为应用、文件系统、数据库三台服务器 通过内网连接

  2. 缓存：为了避免频繁的数据访问 进行缓存 加快处理速度 和 1 同理 也可以做出专门作缓存的内存特化服务器

     后来也就产生了几个分布式缓存系统 比如 Redis 和 Memcached 而分布式带来的问题是 键的哈希方法 如果用传统的取模哈希 增加新的服务器时就会需要大量的重写 于是采用了 Consistent hashing 的方法（后面会细讲）

  3. 更多的应用服务器：无状态的应用服务器是很容易扩展的 因为只需要一模一样的复制即可 而有状态的应用（比如用户的会话状态）比较复杂 需要在分布式中进行数据的同步

     对于分布式的应用服务器 需要负载均衡 可以使用 http 重定向、反向代理等方式，轮询、随机、哈希等策略来实现

  4. 扩展数据库：两种方式 一是做主从复制 二是分库分表

  5. 分布式文件系统：比如 NFS、GFS 等 和分布式数据库比较类似

  6. 使用 CDN：通过内容分发尽可能的减少网络延迟 是一种变相的缓存

  7. 分离不同的应用：比如阿里分为了支付宝和淘宝 可以使用 k8s 进行集群部署

- 分布式系统的 fault 会很多 所以我们希望分布式系统有较好的容灾能力 比如个别集群内的服务器宕机 整个系统仍然可以正常使用

- 分布式系统需要实现高可用性

  - 复制备份：复制一样的系统做同样的事 来作为当前系统的备份 困难是如何维护一致性 比如写完 A 后 还没有复制到 B 就崩溃了
  - Retry 重试：发一次请求失败后再发一次 如果能得到正常响应即可视为正确

- 分布式系统的 CAP 理论

  - Consistency、Availablity、Partition 三者不可能兼得
  - 举例：（不严谨 实际上有更严谨的论文证明）

    假如有两个分区 S1 和 S2 它们之间的连接完全断开 为了符合 P 用户 C 将仍能正常使用 S1 和 S2 接下来 C 给 S1 发送一条`A=V1`的请求 为了符合 A S1 必须立即响应请求给 C（否则就相当于有一段时间系统不可用）如果这时 S1 和 C 的连接断开 C 将只能向 S2 进行查询 此时获取的数据就是和之前不一致的了（因为 S1 没办法和它保持一致）

  - 因此我们必须要做权衡 P 是比较必要的 因为不能指望单主机可以做到可靠 因此在 A 和 C 里进行二选一
  - 淘宝这样的应用就会选择 A 尽管可能会产生数据不一致（比如一本书卖个了两个人） 带来的损失也不大（退款呗）
  - 支付宝这样的应用就要选择 C 毕竟转账支付不能产生不一致 要不然会被钻漏洞或者起诉 这也是为什么支付宝转账会比较久（在同步数据）
  - 当然 如果没有网络故障 CAP 还是可以达到的 理论只是告诉你一个分布式系统不可能永远保持 CAP

- 分布式系统需要哪些属性（审视系统的五个维度）？
  1. 可扩展性
  2. 性能
  3. 故障容忍度
  4. 一致性
  5. 易用性

## LEC 3: File System 1

### iNode-based File System（单机文件系统）

- 一个文件有两个属性：持久化且有名字

- 磁盘会提供最简单的读写数据两个 API 而驱动会抽象成文件系统需要使用的更复杂的 API

- 文件为了可扩展性 需要设计成分布式的存储 即不连续的 sector 那就得使用元数据来存储这个 sector 属于哪个文件

- L1：Block 层

  - block 是文件系统中数据管理的基本单元 包含连续的多个 sector 可以调整大小
  - block 大小不能太大 会有空闲 不能太小 会浪费效率
  - 第一个 block 叫做 super block 用于存储文件系统的元数据 比如 block 大小、空闲的 block 数等 后面跟着一个 bitmap 存储所有 block 是否空闲 不过这样要查找一个空闲块就需要遍历了

- L2：File 层

  - inode（index node）会存储文件的元数据 包括这个文件有哪些块 inode 对于大文件来说会很大 所以会做多层映射（类似多级页表）

- L3：inode Number 层

  - 一个 inode table 存储 inode 的位置

- L4：File Name 层

  - 提供文件名到 inode num 的映射 便于根据文件名查找文件
  - 这个映射存储在一个文件里 名为 directory（目录）

- L5：Path Name 层

  - 即使用`/`区分的文件路径

- L6：Absolute path name 层

  - 引入根目录`/` 根目录的 inode 为第 1 个

- L7：Symbolic Link 层（软链接）

  - 硬链接：
    - 即为长路径文件创建快捷方式 相当于创建指向同一个 inode number 的指针
    - 为了防止两个快捷方式指向同一个 inode 而导致的影响 有一个 refcnt 记录 inode 有多少硬链接引用
    - 为了防止 link 成环带来的影响 dr 指令删除文件夹是必须为空的 且文件夹不能指向文件夹
    - `.`和`..`都是硬链接
  - 为了实现跨文件系统（比如多个硬盘）引入软链接：
    - 实际上软链接记录了路径这个字符串 而不是实际的指针 因此文件即使不存在也可以创建软链接

- Rename

  - 重命名时实际上是创建新文件后删除原文件 防止程序崩溃导致丢失

- Summary
  - 文件名不是文件的一部分 而是存在 directory 里的一个字符串 正因此 重命名实际上只能通过创建新文件来实现
  - 硬链接是等价的 不存在先后主次
  - directory 存储了各个文件名 是很小的 不像电脑里展示的那样 文件夹大小包含文件

## LEC 4: File System 2

### File System API

- OPEN/READ/WRITE

  - inode 中包含的文件元数据除了之前提到的 还包括属于哪个用户/组 可读写执行 三个最后修改的时间戳（读 写 链接）

  - 打开一个文件需要：

    - check 用户权限
    - 更新访问时间戳
    - 返回一个 fd 描述符（fd 也可以表示其他硬件 比如键盘显示器等）

  - 为什么返回 fd 而不是其他的选择？

    - 如果返回一个指针 用户态就可以访问内核态的结构 并且可以通过偏移量访问其他未检查的文件 十分不安全
    - fd 将会完全控制用户打开文件的过程和权限

  - Flie Cursor

    - 记录这个 fd 当前读到的位置

  - fd table 和 flie table

    - 每一个进程都有自己的 fd table 所有进程共享一个 file table（打开文件表）子进程会继承父进程的 fd 表 因此共享 cursor 位置

  - 由于每次 read 都会导致对于 inode 的写（要修改 atime）linux 提供参数 no-atime 使得当最后关闭文件时才进行修改

  - 由于数据泄露的问题 写时顺序应该采用更新 block bitmap、更新 inode、写入新数据 虽然此种顺序在极端情况下会产生硬盘浪费 但是可以通过扫描磁盘来恢复

- SYNC
  - 为了保证数据落盘 必须提供这个用于同步的API

- 删除一个打开的文件
  - 在linux系统下 文件的inode将会在refcnt归零后进行删除 也就是延迟到关闭文件后删除

- MALH
  - 模块化
  - 抽象化
  - 分层化
  - 层级化
