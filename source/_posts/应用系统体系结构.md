---
title: 《应用系统体系结构》课程笔记
date: 2024-09-23 14:01:00
categories: 课程笔记
tags:
  - 架构
  - 后端
index_img:
banner_img:
excerpt: " "
---

## 预备知识：如何用 Docker 快速部署本地环境？

这门课程将会学习很多技术栈 同时也就势必需要配置很多环境 如果还像以前一样 前端用 npm 手动启动 后端用 IDEA 启动 数据库作为自启动服务 那么后续要装的环境只会越来越多 越来越难管理 不说系统盘会不会爆炸 启动一次完整的项目可能都要花半天 因此使用 Docker 来配置本地的环境 做到一键启动

### 从前端 Vite 项目开始

- 和服务器上的部署都类似 不过我们通常本地的操作系统都是 Windows 官方推荐安装一个图形化前端 Docker Desktop 链接放这里：https://docs.docker.com/desktop/install/windows-install/ 安装完后需要配置虚拟环境 网上文档里都有教学 我就不赘述了 本人是使用了 HyperV

- 还是编写 Dockerfile 和服务器上的部署不同 为了追求本地开发的效率 我们不能再通过先编译生成静态文件复制到容器内部来部署了 这样子部署 开发时无法热重载 代码更改看不到效果

  考虑到本地开发 源代码都是在的 不妨利用挂载来进行热重载 因此采用下面的 Dockerfile：

  ```
  FROM node:18-alpine

  WORKDIR /frontend

  # 只设置启动命令
  CMD ["npm", "start", "--", "--host"]
  ```

  也就是和本地一样直接启动 `--host`参数是用于暴露端口的 不设置的话宿主机无法访问这个端口

- 然后编写一下 docker-compose 文件 和服务器上部署区别不大 加上一个挂载即可

```
  frontend:
    image: ebook-frontend
    container_name: ebook-frontend
    ports:
      - 5173:5173
    networks:
      - my-network
    volumes:
      - ../frontend:/frontend
    command: sh -c "npm install" # 这条命令初次运行需要加上 因为linux环境有些依赖可能需要重新安装 之后就可以注释掉了 因为挂载实现了持久化 后续再有缺少依赖就重新加上
```

- 最后可以用命令行一键拉起 后续也可以在 Docker Desktop 里使用 GUI 来启动 里面还提供了终端、日志、浏览文件等功能 很方便

### 后端 Spring Boot

- 后端的思路是一样的 也是挂载后直接运行即可 注意 maven 的本地依赖也要挂载 要不然每次都需要重新下载 下面贴一下代码
  Dockerfile:

  ```
  FROM maven:3.8-openjdk-17

  WORKDIR /backend

  CMD ["mvn", "spring-boot:run"]

  EXPOSE 8080
  ```

  docker-compose.yml:

  ```
  backend:
  image: ebook-backend
  container_name: ebook-backend
  ports:
    - 8080:8080
  networks:
    - my-network
  volumes:
    - ../backend:/backend
    - E:/.m2/repository:/root/.m2/repository #挂载本地仓库
  env_file:
    - ../deployment/backend/.env
  ```

- ps：本人测试后发现容器内编译+启动大概需要十几秒 而 IDEA 启动却只需要 3-4 秒 不知道这其中的差别在哪 因此还是采用 IDEA 来启动项目

### MySQL 数据库

- 和服务器上部署无区别 另外提一嘴 既然服务器上已经部署了数据库了 其实就无需再在本地配置数据库容器了 直接连服务器方便又省心 Redis也是同理的

## 9.23

### 谈谈应用架构

- 应用服务器首先为了安全考虑（比如数据库的端口不能暴露） 可以把应用和**数据库**、**文件服务器**等分开部署 通过内网访问 防止外网攻击

- 随后可以添加**分布式缓存服务器** 利用服务器的内存来增加读取速度 考虑到缓存需要少写 设计数据库时就可以把一张表拆分为只读数据和多写数据

- 请求一多 就需要**负载均衡服务器**来进行转发 比如 nginx 有一些新的问题就需要解决 比如分布式 session 的处理

- 数据一多 数据库就需要分布式部署 利用**主从复制**就可以做读的负载均衡 以及容灾备份 为了充分利用资源 可以轮流设为主节点 防止从节点过冷 为了保证主节点的可用性 还需要哨兵等中间件

- 图片音频一多 就需要 **CDN 服务器**来进行内容分发 为了单一访问 还需要一个反向代理服务器来代理这些 CDN 服务器

- 为了代码简单 可以把缓存、数据库、文件服务器的操作统一抽象成一个 API 形成**统一数据访问网关**

- 出现 NoSQL 数据库和搜索引擎后 数据访问的逻辑会更复杂 继续在网关里统一编写

- 为了处理异步通信 需要**消息服务器**

- 不同的应用服务器也可以提取出公共的服务 形成**微服务架构** 等待应用调用

### 服务的有状态和无状态

- http 协议是无状态的协议 即没有办法记住用户的状态

  有状态的服务是需要占用资源的 比如把实例放在内存里 但是不能无限扩大 如果要限制资源大小 又会因为 LRU 等策略导致缓冲池的抖动

  因此 要尽量使用无状态的服务 保留必需的有状态实例

- Spring Bean 的作用域（以一个 service 为例）

  - singleton：全局单例（默认）
  - prototype：每调用一次就创建一个新的实例
  - request：每进行一次 http 请求就创建一个
  - session：一次会话创建一个实例
  - application：一个 ServletContext 生命周期创建一个实例
  - websocket：一次 websocket 对话创建一个实例

- ![](https://image.blog.nwdnysl.site/image-e386b0b13719a1472c0f8d15c2f006a4.png)

  数据库连接池=核心数\*2+有效硬盘数 与用户数无关


