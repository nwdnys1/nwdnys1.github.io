---
title: 《数据智能平台设计及实现》课程笔记
date: 2025-02-19 14:36:41
categories: 课程笔记
tags:
  - 开发
  - 大数据
index_img:
banner_img:
excerpt: " "
---

# HW1-知识图谱构建

第一个大作业要求对于大量文本数据（简历）进行处理 提取出知识图谱并持久化存储到 Neo4j 数据库中 并且提供一些简单的查询接口

## 作业要求

1. 简历读取：从文件夹中读取简历，读取方式自行设定。并从 PDF 格式的简历文件中提取文本内容，为后续的文本分析和知识图谱构建提供数据基础。
2. 知识图谱构建：使用 LTP（Language Technology Platform）对提取的文本进行分析，提取关键信息并构建知识图谱。（注：LTP 支持对文本进行分词、词性标注、命名实体识别、依存句法分析和语义角色标注等功能，实际使用内容自行选定）从分析结果中提取关键信息，如工作经验、教育背景、技能等信息，为每个类别的关键信息（工作经验、教育背景、技能、项目）创建节点，并在这些节点之间创建关系，完成知识图谱的构建。
3. 知识图谱存储：使用 Neo4j 图形数据库存储提取的关键信息和关系，实现知识图谱的持久。
4. 简历筛选：支持通过知识图谱快速筛选符合特定职位要求的候选人，包括但不限于用 Neo4j Cypher 查询语言筛选出具有特定技能和工作经验的候选人。
5. 展示应用：通过实际应用展示知识图谱的构建和查询结果，在这一步骤中，编写至少两个查询示例展示如何筛选符合条件的候选人，查询结果应包括候选人的关键信息，如姓名、技能、工作经验等。

## 实现思路

1. 简历读取

   - 项目整体使用 Python 进行开发
   - 读取简历使用 `pdfplumber` 库
   - 可对文本进行预处理 去除换行符方便 llm 提取

2. 知识图谱构建

   - 知识图谱的提取可以使用 `LTP` 或 `LLM` 进行
   - 使用 ltp 提取 基于分词的词性和上下文进行分类 比较笨拙 另外需要预处理文本 因为简历文本的格式不固定 最终弃用
   - 使用 llm 提取 基于预训练模型的命名实体识别和关系抽取 速度快效果好 利用 langchain 现有的接口进行提取 可以指定知识图谱中节点和关系的类型与特性
   - 提取的节点包括：工作经验、教育背景、技能、项目等

3. 知识图谱存储

   - 使用 `Neo4j` 图形数据库进行存储
   - 使用 langchain 提供的`langchain_neo4j`库进行存储

4. 简历筛选

   - 可以进行的查询包括：查询具有特定技能和工作经验的候选人
   - 使用 `Cypher` 查询语言进行查询 编写筛选语法即可

5. 展示应用
   - 使用 `Flask` 框架进行展示 包括两个查询示例 以及简单的前端展示
   - 除了两个基础查询接口以外 还展示了一份关系图（具有相同技能的候选人）以及几份统计图（哪些技能最常见等）

# HW2-分布式流数据处理分析

## 实现思路

1. 基于包含采集数据的 txt 文件定时发送采集数据 模拟实时采集过程

   - txt 文件格式为<时间,数据>
   - xml 里包含了每个文件的含义 即<设备名称,字段>
   - 先用 py 处理 xml 文件 生成一个字典 其中 key 为设备名称 value 为字段列表
   - 然后采集数据时 即可逐个针对每个设备去读取数据流 组合字段形成一个完整的采集数据

2. 使用 DeltaLake(http://delta.io/learn/getting-started/)按照点位对原始
   采集数据进行存储；面向不同设备建立标准数据表，表中应包含某一设备的全部采集
   数据，并按照时间进行合并对齐，对于缺失数据进行相应处理。
   
   - 使用集成了 DeltaLake 的 PySpark 进行数据的读取和存储 数据以 delta 表的格式存储在本地文件系统
   - 读取数据时只需要按 1 中所说 读取每个设备的完整数据 存储前插入缺失值即可

3. 使用批处理或流处理框架，基于 DeltaLake 对供能数据进行静态和动态分析
   （1）主成分分析：分析设备的各个维度（即采集点位）数据间关系，确定能够反映设
   备运行情况的主成分数据。
   提示：可使用 PCA 算法或关联分析算法确定主成分。
   （2）报表生成：分析冷机、热机、三联供系统的综合运行情况，生成日度、周度、月
   度的综合报表。包括但不限于：峰谷值、总供能量、峰值期时长、谷值期时长等，可
   自行设计报表内容。
   提示：可使用 DeltaLake 自带的统计函数或自行实现统计函数来实现。
   （3）趋势预测：根据季节、节假日、每日峰谷潮汐变化等特征，采用时序预测算法或
   模型，预测该能源站冷机、热机、三联供系统的分钟级、小时级供能趋势。
   提示：可使用 ARIMA，Autoencoder，LSTM 等算法实现。一般可建立滑动时间窗口，
   用一段时间窗内的数据作为每个时间点的特征进行预测。

   - 三者皆可以使用 PySpark 进行实现 具体可以倒时候问 LLM

4. 将分析结果展示在 Web 界面中，要求界面清晰简洁，内容完整，展示形
   式丰富，应能展示上述分析结果。参考界面如下：
   （1）设备级数据查询展示界面，可以某月中日期为当前日期，展示对历史数据的查询
   能力和数据的实时更新能力。
   （2）主题数据查询展示界面：按照主题对数据进行查询，如查询温度，可查询到系统
   内所有和温度有关的采集点数据。
   （3）系统级数据综合展示界面：展示一类系统中全部的设备状态信息，同时可以查询
   到该系统的综合报表。
   （4）供能趋势预测界面：展示冷热能在不同算法下的趋势预测，结合当前设备状态、
   供能情况和预测值，给出机组操作的建议（如关停某台设备，降低设备流量等），可
   以某月中日期为当前日期，对结果进行验证。

   - 没什么好说的 写个前后端的事 采用 echarts 进行可视化展示

# HW?- 基于多智能体的赛车模拟

- 分工
  - UI 设计、素材生成
  - 虚拟场景与角色模型构建 编写脚本
  - 接入 LLM 编写各种 agent 的行为逻辑
  - 云端部署
  - 文档、PPT、视频制作

## Unity

- 动画脚本本质上都是 yml 文件 其中通过找到对应名称的对象来进行操作
- 两个命名规则不同的模型 是无法复用同一个动画的 为此 Unity 提供了一个叫做 Avatar 的东西 即替身 可以视为是一个统一的骨骼标准
- 将不同的模型绑定到同一个替身上 它们就都可以使用这个替身为基础制作的动画了
- 动画状态机
  - 包括状态和转换 转换可以设置条件 也可以通过 exit time 来触发
  - 可以设置打断选项 使得在某个状态下可以打断其他状态的动画 而不用等待当前动画播放完毕
  - 新输入系统将不同设备的输入统一为动作 使得在脚本中可以使用动作的状态来进行转移 而不用关心设备输入的是什么键（解耦）
  - Blend Tree 可以用来混合不同的动画状态 使得在不同的输入下可以平滑过渡 比如静止、走路、跑步的过渡 具体而言 一个 tree 有一个变量 这个变量在不同区间对应不同的动画状态 并且可以设置过渡时间和过渡曲线 阈值一般要和动作速度对应 避免出现滑步等问题
  - root motion 选项可以使得动画的位移和旋转由动画本身决定 而不是由脚本控制 本质上 rootmotion 是计算相对位移和旋转进行移动 而脚本是计算绝对位置和角度进行移动 作用是使得动画与场景贴合 避免滑步等问题
  - bake into pose 选项可以使得动画的位移和旋转被固定到骨骼上 使得动画的位移和旋转不会被脚本控制的位移和旋转覆盖 简单来讲 如果这是一个不希望旋转的动画 那么可以勾选这个选项来防止产生旋转 对于不希望位移的动画也是同理
  - 在 root motion 动画中 blendtree 的阈值可以自动选择 但是会出现不同大小的模型速度不同的问题
  - 这时需要在 Start 函数里使用`animator.humanScale`来获取模型的大小 然后传递给 blendtree 的阈值
  - root motion 的目的是为了同步 因此实际速度会上下浮动
  - 为了精准控制速度 需要引入 rigidbody 来控制速度 在 onAnimatorMove 函数中使用`rigidbody.velocity`来控制速度
  - 此时会出现重力加速度无效的问题 这是因为 onAnimatorMove 函数会清零速度 解决方法是让 y 分量速度来自于 rigidbody 的 y 分量速度 其他分量速度来自于 animator 的速度
  - root motion 和 rigidbody 是需要权衡的 根据动画需要的同步或物理实际需求来选择 比如 xz 方向也需要真实的物理效果 那么就需要使用 rigidbody 此时 root motion 失效 就需要自己编写逻辑来控制速度了
  - layer 的作用是可以在不同的层上播放不同的动画 使得动画可以叠加 比如实现人物持枪的同时行走 选择 avatar mask 可以选择哪些骨骼可以被这个层影响
  - additive 的作用是叠加两层动画 比如实现疲劳值的增加
  - sync 的作用是使得两层状态机保持同步 比如实现人物的正常状态和受伤状态的两种状态机 其中 timing 设置可以保证两个状态机同一状态的时间一致
  - layer 中越下面的状态机优先级越高 对于 additive 来说 它会按照权重大小把动画叠加到优先级低的状态机上 对于 override 来说 它会直接覆盖优先级低的状态机
  - 对于不存在动画曲线的动画（比如持枪 不改变手部动作）只能使用 override 不能使用 additive
- IK 可以用于实现人物的手部动作 比如拿枪 简单来讲就是把手绑定到枪上 并通过反向计算位置来让其他骨骼更加自然地跟随
- Animation Rigging 类似于木偶 通过控制木偶的骨骼来控制人物的动作
- 可以使用 event 来触发动画的事件 实现拔枪和收枪的切换
- blender tree 还有 2d 类型 可以用两个变量进行控制 可以实现根据速度方向来切换动画 如果原点存在动画 则会混合原点 否则会混合各个方向的动画
  - 如果需要在同一个方向上混合不同的动画 需要使用 directional blend tree
- Character Controller 是一个简单的碰撞体 用于控制人物的移动 但是它不会受到物理引擎的影响 如果不需要物理效果 可以使用这个组件来控制人物的移动 为了简单添加重力效果 可以用`simpleMove`函数来控制速度
- Cinema Machine 是一个相机控制插件 可以用来控制相机的位置和角度 可以用于切换第一人称和第三人称视角 本质上一个视角使用一个 Virtual Camera 来进行配置即可 其中 follow 用于指定位置 lookat 用于指定角度 可以等实际制作时确定所需要的模式 在细看视频里的属性配置 使用 State Driven Camera 可以根据不同的状态来切换不同的相机
- 跳跃是一个比较复杂的操作 除了动画状态需要设置多个以外 还需要自己编写地面碰撞检测 可以参考 essential 的代码
- 当动画状态机中的状态过多 扩展脚本时太麻烦 此时可以使用 add behaviour 来为每一个状态添加脚本 便于管理
