---
title: 《软件测试》课程笔记
date: 2025-02-19 15:52:41
categories: 课程笔记
tags:
  - 测试
index_img:
banner_img:
excerpt: " "
---

## L1 - 软件测试概述

### IMPORTANCE

- 经典航空事故案例、千年虫等 说明了软件测试的重要性

### CONCEPTS & GLOSSARY

- 软件测试：给程序一定的输入 对比预期输出和实际输出值
- RIPR Model 用于评估一个错误如何才能被观测到
  - Reachability
  - Infection
  - Propagation
  - Revealability
- Myers 准则
  - 越早测试越好
  - 避免让开发者本身进行测试
  - 测试用例=输入数据+预期输出（不可以是自己随意判断的）

## L2 - 基本理论与方法

### Non-Execution Based Testing

- 静态测试：不运行程序 通过检查代码、文档等来发现错误 比如程序员自己检查、代码审查、走查等
- 好处是可以在开发早期进行 尽早发现问题

### Execution Based Testing

- 动态测试：运行程序 通过测试用例来发现错误 包括黑盒测试、白盒测试、灰盒测试等
- 黑盒测试：不关心程序内部结构 只关心输入输出是否符合预期 需要一些测试用例设计技巧来保证覆盖率 比如等价类划分、边界值分析等
- 白盒测试：关心程序内部结构 通过代码覆盖率等指标来评估测试质量 通常需要关注代码的执行路径来设计测试用例 保证覆盖一些边缘情况 比如语句覆盖、分支覆盖等

### Formal Verification

- 形式化验证：通过数学方法来证明程序的正确性 通常用于安全性要求较高的场景 比如航空航天、金融等

### Other Methods

- Def-Use Test：检查变量的定义和使用是否正确
- Mutation Test：通过对程序进行小的变异来检查测试用例的质量
- Regression Test：检查修改代码后是否引入了新的错误
- Fault Stastic：统计错误的分布情况 比如标记重捕法来评估错误的百分比 用于证明测试的有效性
- Reliability Analysis：通过模型来评估软件的可靠性
- Clean Room：？

## L3 - 功能测试

### 边界测试

- 边界测试：测试输入输出的边界情况 即最大最小值、略大略小值以及正常值共 4N+1 个用例
- 依据：单缺陷假设 即假设一个缺陷往往只会导致一个错误
- 健壮性测试：在边界测试的基础上增加无效的异常值 共 6N+1 个用例
- 最坏情况测试：拒绝单缺陷假设 每个维度取 5 个值进行笛卡尔积 共 5^N 个用例 如果需要健壮性 变为 7^N 个用例
- 随机测试：随机生成输入值进行测试 避免人为的测试偏见

### 等价类测试

- 等价类划分：将输入域划分为若干等价类 每个等价类只需要测试一个代表值
- 弱一般等价类（单缺陷）：测试数取等价类最多的维度 可以保证覆盖每个维度的所有划分
- 强一般等价类（多缺陷）：测试数取每个维度划分数的乘积 可以保证覆盖所有可能的组合
- 弱健壮等价类：在弱一般等价类的基础上增加无效值 即每个维度的最大划分和最小划分的外部值 当需要定位错误时 可以增加无效值组合
- 强健壮等价类：在强一般等价类的基础上增加无效值的所有组合

### 基于决策表的测试

- 决策表：描述输入输出之间的关系 包括条件部分和动作部分
- 决策表测试：通过决策表来设计测试用例 保证覆盖所有可能的组合 有时会因为条件太多而导致测试用例数过多

### 测试效率

- 测试用例数：边界测试<等价类测试<决策表测试 同理精细度也是如此

### 指导方针

- 变量是物理量：边界值测试、等价类测试
- 变量是逻辑量：等价类测试、决策表测试
- 变量独立：边界值测试、等价类测试
- 变量不独立：决策表测试
- 单缺陷假设：边界值测试、健壮性测试
- 多缺陷假设：最坏情况测试、决策表测试
- 包含大量例外处理：健壮性测试、决策表测试

## L4 - 结构测试

- 结构测试即根据程序内部逻辑结构进行的白盒测试 其目的是提高测试覆盖率

### 路径测试

- 程序图：描述程序的控制流程的有向图 点表示语句块 边表示控制流 即 i->j 表示 i 执行后 j 可以立马执行
- DD-路径图：一个程序可能会被表示为不同的程序图 但是都可以简化为唯一的 DD-路径图
  - DD-路径：程序图中最小独立的路径 可能有以下几种情况
    - 单个源点或单个汇点
    - 单个入度>=2 或出度>=2 的节点
    - 单个入度=1 且出度=1 的节点
    - 长度>=2 的最长路径
- 测试覆盖指标（部分）
  - 语句覆盖：执行每个语句块至少一次
  - 分支覆盖：执行每个 DD-路径至少一次 即每个判断的真假至少执行一次
  - 条件覆盖：每个判断的不同条件至少执行一次
  - 多条件覆盖：每个判断的所有条件组合至少执行一次
  - 分支/条件覆盖：分支覆盖+条件覆盖
  - 无穷路径覆盖：所有可能的路径至少执行一次
  - 循环覆盖：单循环、嵌套循环、级联循环等
- McCabe 圈数
  - 基路径：类似于基向量 是可以表示程序所有路径的某一组独立路径
    - 基路径必须从起始点到终止点
    - 一条基路径必须包含一条其他所有基路径未包含的边或节点
    - 对于循环 基路径应该包含不执行循环和执行一次循环的路径
  - 圈复杂度：用于定量计算基路径数量的复杂度指标
  - 公式：V(G) = E - N + 2P 其中 E 为边数 N 为节点数 P 为连通分量数（非强连通有向图 如果是强连通 2P 改为 P）
  - 基路径的线性组合只具有数学意义 即加法是路径 i 后接路径 j 乘法是路径的重复执行 减法是去除路径中的边
  - 基路径的寻找基于图的遍历算法 比如 dfs 和 bfs
  - 每一条基路径可以作为一个测试用例 对于所有基路径进行测试后 可以认为所有路径都被覆盖了
  - 基本复杂度：一般而言 一个单元模块的复杂度<10

### 数据流测试

- 路径测试关注的是程序的结构 相对的 数据流测试关注的是程序中数据及其使用的角度
- 定义-使用路径测试
  - 定义节点：变量的输入语句、赋值语句、循环控制语句等 即写入变量的语句
  - 使用节点：变量的输出语句、判断语句、循环控制语句等 即读取变量的语句
    - 谓词使用：语句为谓词语句 比如 if (x > 0)
    - 计算使用：语句非谓词语句 比如 y = x + 1
  - 定义-使用路径：以定义节点为起点 使用节点为终点的路径
  - 定义清除路径：以定义节点为起点 使用节点为终点 且没有其他定义节点的路径
  - 一个即是定义节点又是使用节点的语句一般不被认为是 def-use 路径
- 定义使用路径测试的覆盖指标
  - 全定义准则：每个定义节点到一个使用节点的定义清除路径
  - 全使用准则：每个定义节点到所有使用节点以及后续节点的定义清除路径（后续节点：比如谓词使用后续的逻辑语句）
  - 全谓词使用准则：每个定义节点到所有谓词使用的定义清除路径 若无谓词使用 至少有一个一个计算使用的定义清除路径
  - 全计算使用准则：每个定义节点到所有计算使用的定义清除路径 若无计算使用 至少有一个一个谓词使用的定义清除路径
  - 全定义-使用路径准则：每个定义节点到所有使用节点以及后续节点的定义清除路径 包括有一次环路和无环路的路径
- 基于程序切片的测试
  - 程序切片：给定一个程序和一个变量集合 切片是程序的一个子集 该子集包含了所有对变量做出贡献的语句（及使用或定义了该变量的语句）需要注意后续循环语句的影响 还需要注意控制流的影响
  - 程序切片将程序分为了不同依赖的部分 从而可以更好地定位错误

### 测试效率

- 漏洞与冗余：漏洞是未被测试到的路径 冗余是被多次测试到的路径
- s 是结构单元总数 m 为测试用例个数 n 为覆盖到的结构单元个数
  - 覆盖率 C = n/s
  - 冗余率 R = m/s
  - 净冗余率 NR = m/n

## L5 - 集成测试与系统测试

- 集成测试：需要了解软件的结构和功能 是结构化测试方法 由开发者进行
- 系统测试：不需要了解软件的内部结构 只需要了解软件的功能和需求 是非结构化测试方法 由测试人员或用户进行

### 集成测试

#### 基于功能分解的集成测试

- 自顶向下：从主控模块开始逐步向下集成 为了定位错误 往往用桩程序代替下层模块 完成测试后再逐步用真实程序替换
- 自底向上：从最底层模块开始逐步向上集成 为了定位错误 往往用驱动器代替上层模块 完成测试后再逐步用真实程序替换
- 三明治集成：自顶向下和自底向上的结合
- 大爆炸测试：不分层次 所有单元一次性集成测试

#### 基于调用图的集成测试

- 调用图：描述模块之间的调用关系
- 成对集成：相当于测试调用图的每一条边
- 相邻集成：将相邻节点（直接前驱和后继）作为集合进行测试

#### 基于路径的集成测试

- 模块执行路径：以源节点（其他模块转移到本模块的语句）开始 以汇节点（转移到其他模块的语句）结束 且中间没有其他汇节点的路径 代表的是模块内部的执行路径
- MM-路径：模块间的执行路径 即模块内执行路径的组合 描述了模块之间的调用关系
- 圈复杂度：V(G) = E - N + 2P 其中 E 为边数 N 为节点数 P 为连通分量数 双向边算两条边

### 系统测试

- 系统的功能可以用输入输出来分析 因此可以使用黑盒测试方法进行测试

#### 线索

- 系统级线索是指系统输入到输出的路径（功能的最小单元）
- 原子系统功能（ASF）：在系统层可以观察到的端口输入和输出事件的行动
  - 事件静止特性：开始于一个输入事件 结束于一个输出事件 遍历多个 MM-路径
  - 事件序列原子化特性：ASF 不可再细分
- 系统的 ASF 图是一个有向图 系统线索则是 ASF 图中源到汇的路径

#### 基本概念

- 数据
- 操作
- 设备
- 事件
- 线索：从源 ASF 到汇 ASF 的路径

#### 建立系统 ASF 图

- ASF 相当于一个个状态 整个系统的状态转移图就是系统的 ASF 图

#### 系统测试指导方针

- 齐夫定律：80%的错误来自 20%的功能

## L6 - 单元测试工具

## L7-L8 - GUI 与性能测试

## L9 - 回归测试

- 回归测试：在软件修改后 重新执行之前的测试用例 以验证修改是否引入了新的错误
- 回归测试包的选择
  - 再测试所有测试用例
  - 基于风险选择测试用例
  - 基于操作剖面选择测试用例
- 回归测试的步骤
  1. 识别软件被修改的部分
  2. 从原基线测试用例库 T 中排除不适用的测试用例 形成新的测试用例库 T0
  3. 依据特定策略从 T0 中选择测试用例进行测试
  4. 如果必要 生成新的测试用例集 T1 用于补充测试 T0 无法覆盖的部分
- 回归测试选择用例的方法
  - 基于执行轨迹：选择执行轨迹中被修改的部分 执行轨迹就是测试用例在程序图中的一条路径

## L10 - 变异测试

- 变异测试：通过对程序进行小的变异来检查测试用例的质量
- 核心观点：如果程序修改后 仍能通过测试用例的测试 则说明测试用例对于修改的部分没有覆盖到 这种情况下要么是测试用例设计不合理 要么是程序本身的错误 因此我们希望变异后程序无法通过测试用例的测试
- 变异体：对程序进行小的变异后 形成的新的程序
- 有效测试用例：能够发现变异体的测试用例
- 变异体有可能与原程序是等价的 这种情况下测试用例无法发现变异体
- 一旦测试集无法发现变异体 则说明测试集不够充分 继续添加测试用例
- 变异测试的步骤
  1. 生成变异体集合 M={m1, m2, ..., mn}
  2. 为每个变异体执行测试用例集 T
  3. 统计存活变异体的数量 k1 若 k=k1 则 T 充分 否则计算变异分数 MS=k1/(k-e) 其中 e 为等价变异体的数量
  4. 若 MS=1 则说明测试用例充分 否则继续添加测试用例
- 不同的变异体可能会导致不同的结果 因此测试用例的充分性是对于变异体而言的
- 变异体模拟的是程序员经常会犯的错误 因此变异体的设计需要考虑程序员的思维方式 比如符号、变量、常量的替换
- 变异体的指标
  - 可达性：测试用例必须要覆盖到变异语句 否则一定结果一致
  - 传染性：变异语句会引起状态变化
  - 传播性：执行完变异语句后的不一致状态会导致程序的输出不一致
- 等价变异体通常只能一个一个进行查看才能确定 一般实践时估计等价变异体占比为 5%

## L11 - O-O 测试

- O-O 测试：面向对象的测试方法

### O-O 测试的特点

- O-O 测试的单元：在结构化程序设计中 单元往往是一个函数或过程 而在 O-O 程序设计中 单元往往是一个类或对象
- 类作为测试单元时 存在类的继承和多态性的问题 解决的方法是扁平类 即对有继承的类进行扩充 包含所有父类的属性和方法
- O-O 测试的层次
  - 操作/方法测试
  - 类测试
  - 集成测试
  - 系统测试

### 类测试

- 以方法为测试单元 等价于结构化程序设计中的函数测试 可以使用传统的黑盒和白盒测试方法
- 以类为测试单元 重点在于类的消息序列 即对象之间的消息传递

### 面向对象的集成测试

- 集成测试的 UML 支持：类图、用例图等是进行测试的有力工具
- 顺序图是事件发生的时序 可以认为是一个完整的 MM-路径
- O-O 数据流集成测试框架：事件驱动和消息驱动的 Petri 网——EMDPN
