---
title: 《软件测试》课程笔记
date: 2025-02-19 15:52:41
categories: 课程笔记
tags:
  - 测试
index_img:
banner_img:
excerpt: " "
---

## L1 - 软件测试概述

### IMPORTANCE

- 经典航空事故案例、千年虫等 说明了软件测试的重要性

### CONCEPTS & GLOSSARY

- 软件测试：给程序一定的输入 对比预期输出和实际输出值
- RIPR Model 用于评估一个错误如何才能被观测到
  - Reachability
  - Infection
  - Propagation
  - Revealability
- Myers 准则
  - 越早测试越好
  - 避免让开发者本身进行测试
  - 测试用例=输入数据+预期输出（不可以是自己随意判断的）

## L2 - 基本理论与方法

### Non-Execution Based Testing

- 静态测试：不运行程序 通过检查代码、文档等来发现错误 比如程序员自己检查、代码审查、走查等
- 好处是可以在开发早期进行 尽早发现问题

### Execution Based Testing

- 动态测试：运行程序 通过测试用例来发现错误 包括黑盒测试、白盒测试、灰盒测试等
- 黑盒测试：不关心程序内部结构 只关心输入输出是否符合预期 需要一些测试用例设计技巧来保证覆盖率 比如等价类划分、边界值分析等
- 白盒测试：关心程序内部结构 通过代码覆盖率等指标来评估测试质量 通常需要关注代码的执行路径来设计测试用例 保证覆盖一些边缘情况 比如语句覆盖、分支覆盖等

### Formal Verification

- 形式化验证：通过数学方法来证明程序的正确性 通常用于安全性要求较高的场景 比如航空航天、金融等

### Other Methods

- Def-Use Test：检查变量的定义和使用是否正确
- Mutation Test：通过对程序进行小的变异来检查测试用例的质量
- Regression Test：检查修改代码后是否引入了新的错误
- Fault Stastic：统计错误的分布情况 比如标记重捕法来评估错误的百分比 用于证明测试的有效性
- Reliability Analysis：通过模型来评估软件的可靠性
- Clean Room：？

## L3 - 功能测试

### 边界测试

- 边界测试：测试输入输出的边界情况 即最大最小值、略大略小值以及正常值共 4N+1 个用例
- 依据：单缺陷假设 即假设一个缺陷往往只会导致一个错误
- 健壮性测试：在边界测试的基础上增加无效的异常值 共 6N+1 个用例
- 最坏情况测试：拒绝单缺陷假设 每个维度取 5 个值进行笛卡尔积 共 5^N 个用例 如果需要健壮性 变为 7^N 个用例
- 随机测试：随机生成输入值进行测试 避免人为的测试偏见

### 等价类测试

- 等价类划分：将输入域划分为若干等价类 每个等价类只需要测试一个代表值
- 弱一般等价类（单缺陷）：测试数取等价类最多的维度 可以保证覆盖每个维度的所有划分
- 强一般等价类（多缺陷）：测试数取每个维度划分数的乘积 可以保证覆盖所有可能的组合
- 弱健壮等价类：在弱一般等价类的基础上增加无效值 即每个维度的最大划分和最小划分的外部值 当需要定位错误时 可以增加无效值组合
- 强健壮等价类：在强一般等价类的基础上增加无效值的所有组合

### 基于决策表的测试

- 决策表：描述输入输出之间的关系 包括条件部分和动作部分
- 决策表测试：通过决策表来设计测试用例 保证覆盖所有可能的组合 有时会因为条件太多而导致测试用例数过多

### 测试效率

- 测试用例数：边界测试<等价类测试<决策表测试 同理精细度也是如此

### 指导方针

- 变量是物理量：边界值测试、等价类测试
- 变量是逻辑量：等价类测试、决策表测试
- 变量独立：边界值测试、等价类测试
- 变量不独立：决策表测试
- 单缺陷假设：边界值测试、健壮性测试
- 多缺陷假设：最坏情况测试、决策表测试
- 包含大量例外处理：健壮性测试、决策表测试

## L4 - 结构测试

- 结构测试即根据程序内部逻辑结构进行的白盒测试 其目的是提高测试覆盖率

### 路径测试

- 程序图：描述程序的控制流程的有向图 点表示语句块 边表示控制流 即 i->j 表示 i 执行后 j 可以立马执行
- DD-路径图：一个程序可能会被表示为不同的程序图 但是都可以简化为唯一的 DD-路径图
  - DD-路径：程序图中最小独立的路径 可能有以下几种情况
    - 单个源点或单个汇点
    - 单个入度>=2 或出度>=2 的节点
    - 单个入度=1 且出度=1 的节点
    - 长度>=2 的最长路径
- 测试覆盖指标（部分）
  - 语句覆盖：执行每个语句块至少一次
  - 分支覆盖：执行每个 DD-路径至少一次 即每个判断的真假至少执行一次
  - 条件覆盖：每个判断的不同条件至少执行一次
  - 多条件覆盖：每个判断的所有条件组合至少执行一次
  - 分支/条件覆盖：分支覆盖+条件覆盖
  - 无穷路径覆盖：所有可能的路径至少执行一次
  - 循环覆盖：单循环、嵌套循环、级联循环等
- McCabe 圈数
  - 基路径：类似于基向量 是可以表示程序所有路径的某一组独立路径
    - 基路径必须从起始点到终止点
    - 一条基路径必须包含一条其他所有基路径未包含的边或节点
    - 对于循环 基路径应该包含不执行循环和执行一次循环的路径
  - 圈复杂度：用于定量计算基路径数量的复杂度指标
  - 公式：V(G) = E - N + 2P 其中 E 为边数 N 为节点数 P 为连通分量数（非强连通有向图 如果是强连通 2P 改为 P）
  - 基路径的线性组合只具有数学意义 即加法是路径 i 后接路径 j 乘法是路径的重复执行 减法是去除路径中的边
  - 基路径的寻找基于图的遍历算法 比如 dfs 和 bfs
  - 每一条基路径可以作为一个测试用例 对于所有基路径进行测试后 可以认为所有路径都被覆盖了
  - 基本复杂度：一般而言 一个单元模块的复杂度<10

### 数据流测试

- 路径测试关注的是程序的结构 相对的 数据流测试关注的是程序中数据及其使用的角度
- 定义-使用路径测试
  - 定义节点：变量的输入语句、赋值语句、循环控制语句等 即写入变量的语句
  - 使用节点：变量的输出语句、判断语句、循环控制语句等 即读取变量的语句
    - 谓词使用：语句为谓词语句 比如 if (x > 0)
    - 计算使用：语句非谓词语句 比如 y = x + 1
  - 定义-使用路径：以定义节点为起点 使用节点为终点的路径
  - 定义清除路径：以定义节点为起点 使用节点为终点 且没有其他定义节点的路径
  - 一个即是定义节点又是使用节点的语句一般不被认为是 def-use 路径
- 定义使用路径测试的覆盖指标
  - 全定义准则：每个定义节点到一个使用节点的定义清除路径
  - 全使用准则：每个定义节点到所有使用节点以及后续节点的定义清除路径（后续节点：比如谓词使用后续的逻辑语句）
  - 全谓词使用准则：每个定义节点到所有谓词使用的定义清除路径 若无谓词使用 至少有一个一个计算使用的定义清除路径
  - 全计算使用准则：每个定义节点到所有计算使用的定义清除路径 若无计算使用 至少有一个一个谓词使用的定义清除路径
  - 全定义-使用路径准则：每个定义节点到所有使用节点以及后续节点的定义清除路径 包括有一次环路和无环路的路径
- 基于程序切片的测试
  - 程序切片：给定一个程序和一个变量集合 切片是程序的一个子集 该子集包含了所有对变量做出贡献的语句（及使用或定义了该变量的语句）需要注意后续循环语句的影响 还需要注意控制流的影响
  - 程序切片将程序分为了不同依赖的部分 从而可以更好地定位错误

### 测试效率

- 漏洞与冗余：漏洞是未被测试到的路径 冗余是被多次测试到的路径
- s 是结构单元总数 m 为测试用例个数 n 为覆盖到的结构单元个数  
  - 覆盖率C = n/s
  - 冗余率R = m/s
  - 净冗余率NR = m/n

## L5 - 集成测试与系统测试

- 集成测试：需要了解软件的结构和功能 是结构化测试方法 由开发者进行
- 系统测试：不需要了解软件的内部结构 只需要了解软件的功能和需求 是非结构化测试方法 由测试人员或用户进行

### 集成测试

#### 基于功能分解的集成测试

- 自顶向下：从主控模块开始逐步向下集成 为了定位错误 往往用桩程序代替下层模块 完成测试后再逐步用真实程序替换
- 自底向上：从最底层模块开始逐步向上集成 为了定位错误 往往用驱动器代替上层模块 完成测试后再逐步用真实程序替换
- 三明治集成：自顶向下和自底向上的结合
- 大爆炸测试：不分层次 所有单元一次性集成测试

#### 基于调用图的集成测试

- 调用图：描述模块之间的调用关系
- 成对集成：相当于测试调用图的每一条边
- 相邻集成：将相邻节点（直接前驱和后继）作为集合进行测试

#### 基于路径的集成测试

- 模块执行路径：以源节点（其他模块转移到本模块的语句）开始 以汇节点（转移到其他模块的语句）结束 且中间没有其他汇节点的路径 代表的是模块内部的执行路径
- MM-路径：模块间的执行路径 即模块内执行路径的组合 描述了模块之间的调用关系
- 圈复杂度：V(G) = E - N + 2P 其中 E 为边数 N 为节点数 P 为连通分量数 双向边算两条边

### 系统测试

- 系统的功能可以用输入输出来分析 因此可以使用黑盒测试方法进行测试

#### 线索

- 系统级线索是指系统输入到输出的路径（功能的最小单元）
- 原子系统功能（ASF）：在系统层可以观察到的端口输入和输出事件的行动
  - 事件静止特性：开始于一个输入事件 结束于一个输出事件 遍历多个 MM-路径
  - 事件序列原子化特性：ASF 不可再细分
- 系统的 ASF 图是一个有向图 系统线索则是 ASF 图中源到汇的路径

#### 基本概念

- 数据
- 操作
- 设备
- 事件
- 线索：从源 ASF 到汇 ASF 的路径

#### 建立系统 ASF 图

- ASF 相当于一个个状态 整个系统的状态转移图就是系统的 ASF 图

#### 系统测试指导方针

- 齐夫定律：80%的错误来自 20%的功能

## L? - 软件测试工具

### HW2

以下是为您的电子书店项目 Service 层测试量身定制的测试计划框架，结合 DD 路径和数据流测试方法：

---

### 电子书店系统

### Service 层测试计划

### 版本 1.0

---

### 修订历史记录

| 日期       | 版本 | 说明     | 作者   |
| ---------- | ---- | -------- | ------ |
| [填写日期] | 1.0  | 初始版本 | [姓名] |

---

### 目录

1. 简介
2. 测试需求
3. 测试策略
4. 资源
5. 项目里程碑
6. 可交付工件
7. 附录

---

### 1. 简介

#### 1.1 目的

- 验证电子书店 Service 层关键业务逻辑的正确性
- 评估 DD 路径与数据流测试方法的覆盖率差异
- 识别订单处理、库存管理、用户服务等核心模块的缺陷

#### 1.2 背景

项目包含：

- 订单服务（创建/取消订单）
- 库存服务（书籍库存更新）
- 用户服务（积分计算）
- 采用 Spring 框架实现

#### 1.3 范围

**测试对象**：

- OrderServiceImpl
- InventoryServiceImpl
- UserPointsServiceImpl

**排除项**：

- UI 交互
- 第三方支付接口

---

### 2. 测试需求

| 模块         | 测试方法       | 覆盖目标             |
| ------------ | -------------- | -------------------- |
| 订单创建     | DD 路径+数据流 | 分支覆盖 ≥95%        |
| 库存扣减     | 数据流         | 定义-使用链覆盖 100% |
| 用户积分计算 | DD 路径        | 路径覆盖 ≥90%        |

---

### 3. 测试策略

#### 3.1 测试类型

**3.1.1 DD 路径测试**

- **目标**：验证控制流完整性
- **方法**：
  ```java
  // 示例测试用例（订单创建）
  @Test
  void createOrder_InvalidStock_ThrowsException() {
      when(inventoryDao.getStock(any())).thenReturn(0);
      assertThrows(InventoryException.class, () -> orderService.createOrder(testOrder));
  }
  ```

**3.1.2 数据流测试**

- **目标**：追踪变量定义-使用链
- **方法**：

  ```java
  // 示例测试用例（库存更新）
  @Test
  void updateInventory_DefUseChain() {
      int initialStock = 10;
      when(bookRepo.findById(any())).thenReturn(Optional.of(new Book(initialStock)));

      inventoryService.updateStock("ISBN001", -2);
      verify(bookRepo).save(argThat(b -> b.getStock() == 8)); // 验证定义点和使用点
  }
  ```

#### 3.1.3 覆盖率分析

| 指标          | DD 路径目标 | 数据流目标 | 工具             |
| ------------- | ----------- | ---------- | ---------------- |
| 分支覆盖      | 95%         | 85%        | JaCoCo           |
| 定义-使用覆盖 | -           | 100%       | CodePro Analytix |

---

### 4. 资源

#### 4.1 角色

| 角色         | 人数 | 职责                  |
| ------------ | ---- | --------------------- |
| 测试工程师   | 2    | 设计/执行 DD 路径测试 |
| 数据流分析师 | 1    | 设计数据流测试用例    |

#### 4.2 工具

| 工具类型   | 名称             |
| ---------- | ---------------- |
| 测试框架   | JUnit 5          |
| 覆盖率分析 | JaCoCo + CodePro |
| 模拟框架   | Mockito          |

---

### 5. 项目里程碑

| 任务            | 周期 | 交付物              |
| --------------- | ---- | ------------------- |
| DD 路径测试完成 | 2 周 | 分支覆盖率报告      |
| 数据流测试完成  | 3 周 | 定义-使用链分析报告 |
| 对比分析        | 1 周 | 方法有效性评估文档  |

---

### 6. 可交付工件

1. **测试报告**：
   - DD 路径覆盖率的可视化图表
   - 数据流异常路径检测日志
2. **缺陷报告**：
   - 临界值处理缺陷（如库存负值）
   - 并发修改问题

---

### 7. 附录

**覆盖率提升策略**：

- 对 DD 路径未覆盖的分支补充边界值测试
- 对数据流敏感方法增加异常输入测试

**风险应对**：

- 若 DD 路径覆盖不足：增加状态转换测试
- 若数据流覆盖不足：引入符号执行工具辅助

---

该计划可直接用于指导您的测试实施，重点突出了两种测试方法的对比验证。需要根据实际代码结构调整具体测试用例和覆盖率指标。
