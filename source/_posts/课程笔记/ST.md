---
title: 《软件测试》课程笔记
date: 2025-02-19 15:52:41
categories: 课程笔记
tags:
  - 测试
index_img:
banner_img:
excerpt: " "
---

## L1 - 软件测试概述

### IMPORTANCE

- 经典航空事故案例、千年虫等 说明了软件测试的重要性

### CONCEPTS & GLOSSARY

- 软件测试：给程序一定的输入 对比预期输出和实际输出值
- RIPR Model 用于评估一个错误如何才能被观测到
  - Reachability
  - Infection
  - Propagation
  - Revealability
- Myers 准则
  - 越早测试越好
  - 避免让开发者本身进行测试
  - 测试用例=输入数据+预期输出（不可以是自己随意判断的）

## L2 - 基本理论与方法

### Non-Execution Based Testing

- 静态测试：不运行程序 通过检查代码、文档等来发现错误 比如程序员自己检查、代码审查、走查等
- 好处是可以在开发早期进行 尽早发现问题

### Execution Based Testing

- 动态测试：运行程序 通过测试用例来发现错误 包括黑盒测试、白盒测试、灰盒测试等
- 黑盒测试：不关心程序内部结构 只关心输入输出是否符合预期 需要一些测试用例设计技巧来保证覆盖率 比如等价类划分、边界值分析等
- 白盒测试：关心程序内部结构 通过代码覆盖率等指标来评估测试质量 通常需要关注代码的执行路径来设计测试用例 保证覆盖一些边缘情况 比如语句覆盖、分支覆盖等

### Formal Verification

- 形式化验证：通过数学方法来证明程序的正确性 通常用于安全性要求较高的场景 比如航空航天、金融等

### Other Methods

- Def-Use Test：检查变量的定义和使用是否正确
- Mutation Test：通过对程序进行小的变异来检查测试用例的质量
- Regression Test：检查修改代码后是否引入了新的错误
- Fault Stastic：统计错误的分布情况 比如标记重捕法来评估错误的百分比 用于证明测试的有效性
- Reliability Analysis：通过模型来评估软件的可靠性
- Clean Room：？

## L3 - 功能测试

### 边界测试

- 边界测试：测试输入输出的边界情况 即最大最小值、略大略小值以及正常值共 4N+1 个用例
- 依据：单缺陷假设 即假设一个缺陷往往只会导致一个错误
- 健壮性测试：在边界测试的基础上增加无效的异常值 共 6N+1 个用例
- 最坏情况测试：拒绝单缺陷假设 每个维度取 5 个值进行笛卡尔积 共 5^N 个用例 如果需要健壮性 变为 7^N 个用例
- 随机测试：随机生成输入值进行测试 避免人为的测试偏见

### 等价类测试

- 等价类划分：将输入域划分为若干等价类 每个等价类只需要测试一个代表值
- 弱一般等价类（单缺陷）：测试数取等价类最多的维度 可以保证覆盖每个维度的所有划分
- 强一般等价类（多缺陷）：测试数取每个维度划分数的乘积 可以保证覆盖所有可能的组合
- 弱健壮等价类：在弱一般等价类的基础上增加无效值 即每个维度的最大划分和最小划分的外部值 当需要定位错误时 可以增加无效值组合
- 强健壮等价类：在强一般等价类的基础上增加无效值的所有组合

### 基于决策表的测试

- 决策表：描述输入输出之间的关系 包括条件部分和动作部分
- 决策表测试：通过决策表来设计测试用例 保证覆盖所有可能的组合 有时会因为条件太多而导致测试用例数过多

### 测试效率

- 测试用例数：边界测试<等价类测试<决策表测试 同理精细度也是如此

### 指导方针

- 变量是物理量：边界值测试、等价类测试
- 变量是逻辑量：等价类测试、决策表测试
- 变量独立：边界值测试、等价类测试
- 变量不独立：决策表测试
- 单缺陷假设：边界值测试、健壮性测试
- 多缺陷假设：最坏情况测试、决策表测试
- 包含大量例外处理：健壮性测试、决策表测试

### HW1

#### 1. 测试计划

##### 1.1 目标与背景

本文为基于大模型的文本生成应用（假设名为 DeepSeek）的测试计划，重点测试五个主要功能：计算器、字数统计、编程任务、情感分析和生成总结。通过设计具体的测试用例，验证该模型的输出准确性与稳定性。本测试会结合**边界值分析**、**等价类划分**和**决策表**三种测试方法，重点测试计算器功能、字数统计功能、编程任务生成与情感分析功能。

##### 1.2 测试方法

- **边界值分析**：通过测试输入的边界值，确保模型在处理边界数据时不会发生错误。
- **等价类划分**：将输入数据分成有效和无效的等价类，进行测试。
- **决策表**：通过不同输入条件的组合，设计决策表，测试不同条件的输出是否符合预期。

---

#### 2. 测试用例设计

##### 2.1 计算器功能测试用例

**功能**：验证计算器的基本计算功能，尤其是边界数字、负数以及极大数字的处理。

- **测试方法**：边界值分析、等价类划分
- **边界值**：非常大的数字、负数、零、最小值

| 测试用例编号 | 输入表达式              | 预期输出          | 测试方法   | 备注           |
| ------------ | ----------------------- | ----------------- | ---------- | -------------- |
| TC1          | `5 + 3`                 | `8`               | 等价类划分 | 基本加法操作   |
| TC2          | `1000000 * 999999`      | `999999000000`    | 边界值分析 | 大数值相乘     |
| TC3          | `-5 + 3`                | `-2`              | 等价类划分 | 负数运算       |
| TC4          | `0 * 1000`              | `0`               | 等价类划分 | 乘法与零值操作 |
| TC5          | `99999999999999 + 1000` | `100000000000099` | 边界值分析 | 极大数字求和   |

##### 2.2 字数统计功能测试用例

**功能**：验证字数统计的准确性，尤其是在文本较长或为空时的表现。

- **测试方法**：边界值分析、等价类划分
- **边界值**：空文本、单字文本、长文本

| 测试用例编号 | 输入文本                                        | 预期输出 | 测试方法   | 备注                    |
| ------------ | ----------------------------------------------- | -------- | ---------- | ----------------------- |
| TC1          | `"Hello World"`                                 | `2`      | 等价类划分 | 常规两个词文本          |
| TC2          | `""`                                            | `0`      | 边界值分析 | 空文本                  |
| TC3          | `"A" * 1000`                                    | `1000`   | 边界值分析 | 超长文本（1000 个字母） |
| TC4          | `"The quick brown fox jumps over the lazy dog"` | `9`      | 等价类划分 | 一段常规文本            |
| TC5          | `"a"`                                           | `1`      | 等价类划分 | 单字文本                |

##### 2.3 编程任务生成测试用例

**功能**：验证生成代码的功能，测试系统在生成代码时的语言及功能准确性。

- **测试方法**：等价类划分、决策表
- **边界值**：常见算法的实现，语言规范的不同

| 测试用例编号 | 输入请求                                          | 预期输出                            | 测试方法   | 备注                                   |
| ------------ | ------------------------------------------------- | ----------------------------------- | ---------- | -------------------------------------- |
| TC1          | `Write a Python function to calculate factorial`  | Python 代码段，正确实现阶乘函数     | 等价类划分 | 编程语言支持及算法正确性               |
| TC2          | `Generate JavaScript code for bubble sort`        | JavaScript 代码，正确实现冒泡排序   | 等价类划分 | 不同语言下的排序算法实现               |
| TC3          | `Write a C++ program for prime number generation` | C++代码，正确实现素数生成程序       | 等价类划分 | 不同语言支持，算法正确性               |
| TC4          | `Generate Python code to reverse a string`        | Python 代码，正确实现字符串反转功能 | 决策表     | 针对不同的编程问题，生成符合逻辑的代码 |

##### 2.4 情感分析功能测试用例

**功能**：验证模型在情感分析方面的表现，特别是对情感强度和复杂情绪的判断。

- **测试方法**：边界值分析、决策表
- **边界值**：极端情绪、情感中立文本

| 测试用例编号 | 输入文本                                   | 预期输出   | 测试方法   | 备注                   |
| ------------ | ------------------------------------------ | ---------- | ---------- | ---------------------- |
| TC1          | `"I love programming!"`                    | `Positive` | 边界值分析 | 强烈正面情感           |
| TC2          | `"I hate bugs!"`                           | `Negative` | 边界值分析 | 强烈负面情感           |
| TC3          | `"It was an okay day."`                    | `Neutral`  | 决策表     | 中立情感               |
| TC4          | `"I feel happy and sad at the same time."` | `Mixed`    | 决策表     | 复杂情感，混合情绪分析 |
| TC5          | `"I'm not sure how I feel."`               | `Neutral`  | 决策表     | 模棱两可的情感分析     |

##### 2.5 生成总结功能测试用例

**功能**：验证模型在处理长文本时生成摘要的准确性和简洁性。

- **测试方法**：等价类划分、边界值分析
- **边界值**：极短、极长、常规长度文本

| 测试用例编号 | 输入文本                                                                                                                                                                                                            | 预期输出                                                         | 测试方法   | 备注                 |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | ---------- | -------------------- |
| TC1          | `"The quick brown fox jumps over the lazy dog."`                                                                                                                                                                    | `"A fox jumped over a dog."`                                     | 等价类划分 | 简单句子生成简洁摘要 |
| TC2          | `"The quick brown fox jumps over the lazy dog. It was a beautiful day in the park, and the fox was full of energy. The dog remained resting in the sun."`                                                           | `"A fox jumped over a dog, while the dog rested peacefully."`    | 边界值分析 | 长文本生成简洁摘要   |
| TC3          | `"Once upon a time, in a land far away, there was a young princess. She loved adventure and often went into the forest to explore. One day, she met a mysterious creature who changed her life forever."`           | `"A princess met a mysterious creature who changed her life."`   | 边界值分析 | 长篇故事的精简摘要   |
| TC4          | `"I am not a robot, I am a human being, just like you. I can feel the emotions of joy, sadness, excitement, and fear. I am capable of experiencing the wonders of the world, and I appreciate the beauty of life."` | `"A human being experiencing emotions and the wonders of life."` | 等价类划分 | 对长段情感表达的总结 |

---

#### 3.1 测试执行情况

- **计算器功能**：所有计算测试用例通过，包括大数字运算、负数运算和零值操作。
- **字数统计功能**：处理空文本、单字文本和极长文本时准确无误。
- **编程任务**：生成的 Python、JavaScript 和 C++代码均符合功能要求，能够正确实现所请求的算法。
- **情感分析功能**：模型准确识别正面、负面、复杂和中立情感，处理混合情感的能力较强。
- **生成总结功能**：摘要生成效果良好，能够在长文本中提取出核心信息并进行简洁总结。

#### 3.2 测试结果总结

所有测试用例均通过，表明系统在处理多种文本生成任务时表现稳定且准确。尤其是在边界情况和极端输入的处理上，模型能够正确输出预期结果。建议继续优化生成总结的深度，尤其是在非常长文本中的摘要生成表现上。

#### 3.3 问题与改进建议

- **计算器功能**：对于极大数字的计算，偶尔存在延迟，建议优化性能。
- **编程任务**：生成的代码在复杂任务时有时不够简洁，建议进一步改进代码质量。
- **生成总结**：对于极长文本的摘要生成可以进一步提高信息提炼能力，避免过于简短的摘要。

## L4 - 结构测试

- 结构测试即根据程序内部逻辑结构进行的白盒测试 其目的是提高测试覆盖率

### 路径测试

- 程序图：描述程序的控制流程的有向图 点表示语句块 边表示控制流 即 i->j 表示 i 执行后 j 可以立马执行
- DD-路径图：一个程序可能会被表示为不同的程序图 但是都可以简化为唯一的 DD-路径图
  - DD-路径：程序图中最小独立的路径 可能有以下几种情况
    - 单个源点或单个汇点
    - 单个入度>=2 或出度>=2 的节点
    - 单个入度=1 且出度=1 的节点
    - 长度>=2 的最长路径
- 测试覆盖指标（部分）
  - 语句覆盖：执行每个语句块至少一次
  - 分支覆盖：执行每个 DD-路径至少一次 即每个判断的真假至少执行一次
  - 条件覆盖：每个判断的不同条件至少执行一次
  - 多条件覆盖：每个判断的所有条件组合至少执行一次
  - 分支/条件覆盖：分支覆盖+条件覆盖
  - 无穷路径覆盖：所有可能的路径至少执行一次
  - 循环覆盖：单循环、嵌套循环、级联循环等
- McCabe 圈数
  - 基路径：类似于基向量 是可以表示程序所有路径的某一组独立路径
    - 基路径必须从起始点到终止点
    - 一条基路径必须包含一条其他所有基路径未包含的边或节点
    - 对于循环 基路径应该包含不执行循环和执行一次循环的路径
  - 圈复杂度：用于定量计算基路径数量的复杂度指标
  - 公式：V(G) = E - N + 2P 其中 E 为边数 N 为节点数 P 为连通分量数（非强连通有向图 如果是强连通 2P 改为 P）
  - 基路径的线性组合只具有数学意义 即加法是路径 i 后接路径 j 乘法是路径的重复执行 减法是去除路径中的边
  - 基路径的寻找基于图的遍历算法 比如 dfs 和 bfs
  - 每一条基路径可以作为一个测试用例 对于所有基路径进行测试后 可以认为所有路径都被覆盖了
  - 基本复杂度：一般而言 一个单元模块的复杂度<10

### 数据流测试

- 路径测试关注的是程序的结构 相对的 数据流测试关注的是程序中数据及其使用的角度
- 定义-使用路径测试
  - 定义节点：变量的输入语句、赋值语句、循环控制语句等 即写入变量的语句
  - 使用节点：变量的输出语句、判断语句、循环控制语句等 即读取变量的语句
    - 谓词使用：语句为谓词语句
    - 计算使用：语句非谓词语句
  - 定义-使用路径：以定义节点为起点 使用节点为终点的路径
  - 定义清除路径：以定义节点为起点 使用节点为终点 且没有其他定义节点的路径
  - 一个即是定义节点又是使用节点的语句一般不被认为是 def-use 路径
- 定义使用路径测试的覆盖指标
  - 全定义准则：每个定义节点到一个使用节点的定义清除路径
  - 全使用准则：每个定义节点到所有使用节点以及后续节点的定义清除路径
  - 全谓词使用准则：每个定义节点到所有谓词使用的定义清除路径 若无谓词使用 至少有一个一个计算使用的定义清除路径
  - 全计算使用准则：每个定义节点到所有计算使用的定义清除路径 若无计算使用 至少有一个一个谓词使用的定义清除路径
  - 全定义-使用路径准则：每个定义节点到所有使用节点以及后续节点的定义清除路径 包括有一次环路和无环路的路径
- 基于程序切片的测试
  - 程序切片：给定一个程序和一个变量集合 切片是程序的一个子集 该子集包含了所有对变量做出贡献的语句（及使用或定义了该变量的语句）
  - 程序切片将程序分为了不同依赖的部分 从而可以更好地定位错误

### 测试效率

- 漏洞与冗余：漏洞是未被测试到的路径 冗余是被多次测试到的路径
- m 为测试用例个数 n 为覆盖到的结构单元个数 s 是结构单元总数 则覆盖率为 n/s R 为 m/s NR 为 n/m

## L5 - 集成测试与系统测试

- 集成测试：需要了解软件的结构和功能 是结构化测试方法 由开发者进行
- 系统测试：不需要了解软件的内部结构 只需要了解软件的功能和需求 是非结构化测试方法 由测试人员或用户进行

### 集成测试

#### 集成测试的方法

- 自顶向下：从主控模块开始逐步向下集成 为了定位错误 往往用桩程序代替下层模块 完成测试后再逐步用真实程序替换
- 自底向上：从最底层模块开始逐步向上集成 为了定位错误 往往用驱动器代替上层模块 完成测试后再逐步用真实程序替换
- 三明治集成：自顶向下和自底向上的结合
- 大爆炸测试：不分层次 所有单元一次性集成测试

#### 基于调用图的集成测试

- 调用图：描述模块之间的调用关系
- 成对集成：相当于测试调用图的每一条边
- 相邻集成：将相邻节点（直接前驱和后继）作为集合进行测试

#### 基于路径的集成测试

- 模块执行路径：以源节点（其他模块转移到本模块的语句）开始 以汇节点（转移到其他模块的语句）结束 且中间没有其他汇节点的路径 代表的是模块内部的执行路径
- MM-路径：模块间的执行路径 即模块内执行路径的组合 描述了模块之间的调用关系
